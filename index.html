<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tilemap Editor</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        margin: 0;
        height: 100vh;
      }

      .menu {
        flex: 0 0 16px;
        background-color: gainsboro;
        margin: 0;
        padding: 0;
      }

      .menu ol {
        list-style-type: none;
        padding: 0;
        margin: 0;
      }

      .menu ol button {
        border: none;
      }

      .menu-icon-bar {
        background-color: gainsboro;
      }

      .menu-icon-bar__button--enabled {
        background-color: rgb(250, 250, 250);
      }

      .container {
        flex: 1 1 auto;
        display: flex;
        flex-direction: row;
        overflow: hidden;
      }

      .sidebar {
        flex: 0 1 200px;
        overflow: auto;
        position: relative;
      }

      .tile-hover {
        border: 1px solid gainsboro;
        box-sizing: border-box;
        position: absolute;
        pointer-events: none;
      }

      .tile-selected {
        border: 1px solid black;
        box-sizing: border-box;
        position: absolute;
        pointer-events: none;
      }

      .slider {
        flex: 0 0 auto;
        border-right: 1px solid black;
        width: 0;
        cursor: col-resize;
      }

      .main {
        flex: 1 1 auto;
        overflow: auto;
        position: relative;
      }

      .level {
        position: fixed;
        right: 0.5rem;
        bottom: 0.5rem;
        width: 32px;
      }
    </style>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0"
    />
  </head>
  <body>
    <menu class="menu">
      <ol>
        <li><button>File</button></li>
      </ol>
    </menu>
    <div class="container">
      <div class="sidebar">
        <img class="tile-set" src="tileset.png" alt="Tileset" />
        <div class="tile-hover" style="display: none"></div>
        <div class="tile-selected" style="display: none"></div>
      </div>
      <div class="slider"></div>
      <div class="main">
        <div class="menu-icon-bar">
          <button type="button" class="toggle-grid-button">
            <span class="material-symbols-outlined"> grid_on </span>
          </button>
        </div>
        <canvas width="1024" height="1024"></canvas>
        <input class="level" type="number" value="0" title="Level" />
      </div>
    </div>
  </body>
  <script>
    let level = 0
    const isGridShownSerialized = localStorage.getItem('isGridShown')
    let isGridShown = isGridShownSerialized
      ? JSON.parse(isGridShownSerialized)
      : true

    const $level = document.querySelector('.level')

    $level.addEventListener('change', function (event) {
      level = Number(event.target.value)
      renderTileMap()
    })

    const $sidebar = document.querySelector('.sidebar')

    const $slider = document.querySelector('.slider')
    let isSliding = false
    $slider.addEventListener('pointerdown', function (event) {
      event.preventDefault()
      isSliding = true
    })
    window.addEventListener('pointermove', function (event) {
      if (isSliding) {
        event.preventDefault()
        $sidebar.style.flexBasis = event.clientX + 'px'
      }
    })
    window.addEventListener('pointerup', function () {
      isSliding = false
    })

    const $tileHover = document.querySelector('.tile-hover')
    const $tileSet = document.querySelector('.tile-set')
    $tileSet.addEventListener('pointermove', function (event) {
      $tileHover.style.display = 'block'
      $tileHover.style.left =
        adjustToStep(event.offsetX, tileMap.tileSize.width) + 'px'
      $tileHover.style.top =
        adjustToStep(event.offsetY, tileMap.tileSize.height) + 'px'
    })

    const $tileSelected = document.querySelector('.tile-selected')

    let isPointerDownInTileSet = false

    $tileSet.addEventListener('pointerdown', function (event) {
      event.preventDefault()
      isPointerDownInTileSet = true
      selectTile(event)
    })

    $tileSet.addEventListener('pointermove', function (event) {
      if (isPointerDownInTileSet) {
        expandSelectTiles(event)
      }
    })

    $tileSet.addEventListener('mouseleave', function () {
      $tileHover.style.display = 'none'
    })

    let firstPoint = null
    let selectedTiles = null

    function selectTile(event) {
      const x = adjustToStep(event.offsetX, tileMap.tileSize.width)
      const y = adjustToStep(event.offsetY, tileMap.tileSize.height)
      firstPoint = {
        x,
        y,
      }
      selectedTiles = {
        x,
        y,
        width: tileMap.tileSize.width,
        height: tileMap.tileSize.height,
      }
      $tileSelected.style.display = 'block'
      $tileSelected.style.left = selectedTiles.x + 'px'
      $tileSelected.style.top = selectedTiles.y + 'px'
      $tileSelected.style.width = selectedTiles.width + 'px'
      $tileSelected.style.height = selectedTiles.height + 'px'
    }

    function expandSelectTiles(event) {
      const x = adjustToStep(event.offsetX, tileMap.tileSize.width)
      const y = adjustToStep(event.offsetY, tileMap.tileSize.height)
      selectedTiles = {
        x: Math.min(firstPoint.x, x),
        y: Math.min(firstPoint.y, y),
        width: Math.abs(x - firstPoint.x) + tileMap.tileSize.width,
        height: Math.abs(y - firstPoint.y) + tileMap.tileSize.height,
      }
      $tileSelected.style.left = selectedTiles.x + 'px'
      $tileSelected.style.top = selectedTiles.y + 'px'
      $tileSelected.style.width = selectedTiles.width + 'px'
      $tileSelected.style.height = selectedTiles.height + 'px'
    }

    window.addEventListener('pointerup', function () {
      isPointerDownInTileSet = false
    })

    function adjustToStep(value, step) {
      return Math.floor(value / step) * step
    }

    const $canvas = document.querySelector('canvas')
    const context = $canvas.getContext('2d')

    let previewTiles = null

    const DEFAULT_MAP_WIDTH = 512
    const DEFAULT_MAP_HEIGHT = 512
    const tileMapSerialized = localStorage.getItem('tileMap')
    let tileMap = tileMapSerialized
      ? JSON.parse(tileMapSerialized)
      : {
          size: {
            width: DEFAULT_MAP_WIDTH,
            height: DEFAULT_MAP_HEIGHT,
          },
          tileSize: {
            width: 32,
            height: 32,
          },
          tiles: [new Array(DEFAULT_MAP_WIDTH * DEFAULT_MAP_HEIGHT)],
        }
    level = tileMap.tiles.length - 1
    $level.value = level

    $tileHover.style.width = tileMap.tileSize.width + 'px'
    $tileHover.style.height = tileMap.tileSize.height + 'px'

    $tileSelected.style.width = tileMap.tileSize.width + 'px'
    $tileSelected.style.height = tileMap.tileSize.height + 'px'

    if (tileMapSerialized) {
      $tileSet.addEventListener('load', function () {
        renderTileMap()
      })
    }

    function retrieveTile(position) {
      const row = position.y / tileMap.tileSize.height + 1
      const column = position.x / tileMap.tileSize.width + 1
      const index = (row - 1) * tileMap.size.width + (column - 1)
      return tileMap.tiles.map(levelTileMap =>
        levelTileMap ? levelTileMap[index] : null
      )
    }

    let firstPointTileMap = null
    let selectedTilesInTileMap = null
    let isPointerDownInTileMap = false

    $canvas.addEventListener('pointerdown', function (event) {
      event.preventDefault()
      isPointerDownInTileMap = true

      selectTileInTileMap(event)

      if (selectedTiles) {
        if (!seemsThat9SliceIsSelected()) {
          setTiles(event)
        }
      }
    })

    function selectTileInTileMap(event) {
      const x = adjustToStep(event.offsetX, tileMap.tileSize.width)
      const y = adjustToStep(event.offsetY, tileMap.tileSize.height)
      firstPointTileMap = {
        x,
        y,
      }

      selectedTilesInTileMap = {
        x,
        y,
        width: tileMap.tileSize.width,
        height: tileMap.tileSize.height,
      }
    }

    function preview9SliceMade() {
      renderTileMap()

      do9SliceMethodWithSelectedTiles(function ({ row, column }, tile) {
        context.drawImage(
          $tileSet,
          tile.x,
          tile.y,
          tileMap.tileSize.width,
          tileMap.tileSize.height,
          selectedTilesInTileMap.x + column * tileMap.tileSize.width,
          selectedTilesInTileMap.y + row * tileMap.tileSize.height,
          tileMap.tileSize.width,
          tileMap.tileSize.height
        )
      })
    }

    $canvas.addEventListener('pointermove', function (event) {
      if (selectedTiles) {
        if (isPointerDownInTileMap) {
          if (seemsThat9SliceIsSelected()) {
            expandSelectTilesInTileMap(event)
            if (
              selectedTilesInTileMap.width > tileMap.tileSize.width ||
              selectedTilesInTileMap.height > tileMap.tileSize.height
            ) {
              preview9SliceMade()
            }
          } else {
            setTiles(event)
          }
        } else {
          const previousPreviewTiles = previewTiles
          previewTiles = {
            x: adjustToStep(event.offsetX, tileMap.tileSize.width),
            y: adjustToStep(event.offsetY, tileMap.tileSize.height),
            width: selectedTiles.width,
            height: selectedTiles.height,
          }
          if (
            !previousPreviewTiles ||
            areDifferent(previousPreviewTiles, previewTiles)
          ) {
            if (previousPreviewTiles) {
              renderTiles(previousPreviewTiles)
              renderGrid()
            }
            renderPreviewTiles()
          }
        }
      }
    })

    function expandSelectTilesInTileMap(event) {
      const x = adjustToStep(event.offsetX, tileMap.tileSize.width)
      const y = adjustToStep(event.offsetY, tileMap.tileSize.height)
      selectedTilesInTileMap = {
        x: Math.min(firstPointTileMap.x, x),
        y: Math.min(firstPointTileMap.y, y),
        width: Math.abs(x - firstPointTileMap.x) + tileMap.tileSize.width,
        height: Math.abs(y - firstPointTileMap.y) + tileMap.tileSize.height,
      }
    }

    function seemsThat9SliceIsSelected() {
      return (
        selectedTiles.width === 3 * tileMap.tileSize.height &&
        selectedTiles.height === 3 * tileMap.tileSize.height
      )
    }

    $canvas.addEventListener('mouseleave', function () {
      if (previewTiles) {
        renderTiles(previewTiles)
        renderGrid()
        previewTiles = null
      }
    })

    window.addEventListener('pointerup', function () {
      const wasPointerDownInTileMap = isPointerDownInTileMap

      isPointerDownInTileMap = false

      if (wasPointerDownInTileMap) {
        if (seemsThat9SliceIsSelected()) {
          if (
            selectedTilesInTileMap.width === tileMap.tileSize.width &&
            selectedTilesInTileMap.height === tileMap.tileSize.height
          ) {
            putSelectedTilesOnMap()
          } else {
            setTilesWith9SliceMethod()
          }
        }
      }

      firstPointTileMap = null
      selectedTilesInTileMap = null
    })

    function putSelectedTilesOnMap() {
      setTiles({
        offsetX: firstPointTileMap.x,
        offsetY: firstPointTileMap.y,
      })
    }

    function setTilesWith9SliceMethod() {
      const baseRow =
        adjustToStep(selectedTilesInTileMap.y, tileMap.tileSize.height) /
        tileMap.tileSize.height
      const baseColumn =
        adjustToStep(selectedTilesInTileMap.x, tileMap.tileSize.width) /
        tileMap.tileSize.width

      do9SliceMethodWithSelectedTiles(function ({ row, column }, tile) {
        setTile(
          {
            row: 1 + baseRow + row,
            column: 1 + baseColumn + column,
          },
          tile
        )
      })
    }

    function doSomethingWithSelectedTilesInTileMap(fn) {
      const numberOfRows = calculateNumberOfRows(selectedTilesInTileMap.height)
      const numberOfColumns = calculateNumberOfColumns(
        selectedTilesInTileMap.width
      )

      for (let row = 0; row < numberOfRows; row++) {
        for (let column = 0; column < numberOfColumns; column++) {
          fn({ row, column })
        }
      }
    }

    function do9SliceMethodWithSelectedTiles(fn) {
      const numberOfRows = calculateNumberOfRows(selectedTilesInTileMap.height)
      const numberOfColumns = calculateNumberOfColumns(
        selectedTilesInTileMap.width
      )

      doSomethingWithSelectedTilesInTileMap(function ({ row, column }) {
        let selectedTilesX
        let selectedTilesY

        if (row === 0 && column === 0) {
          selectedTilesX = selectedTiles.x
          selectedTilesY = selectedTiles.y
        } else if (row === 0 && column === numberOfColumns - 1) {
          ;(selectedTilesX = selectedTiles.x + 2 * tileMap.tileSize.width),
            (selectedTilesY = selectedTiles.y)
        } else if (row === numberOfRows - 1 && column === numberOfColumns - 1) {
          selectedTilesX = selectedTiles.x + 2 * tileMap.tileSize.width
          selectedTilesY = selectedTiles.y + 2 * tileMap.tileSize.height
        } else if (row === numberOfRows - 1 && column === 0) {
          selectedTilesX = selectedTiles.x
          selectedTilesY = selectedTiles.y + 2 * tileMap.tileSize.height
        } else if (row === 0) {
          selectedTilesX = selectedTiles.x + 1 * tileMap.tileSize.width
          selectedTilesY = selectedTiles.y
        } else if (row === numberOfRows - 1) {
          selectedTilesX = selectedTiles.x + 1 * tileMap.tileSize.width
          selectedTilesY = selectedTiles.y + 2 * tileMap.tileSize.height
        } else if (column === 0) {
          selectedTilesX = selectedTiles.x
          selectedTilesY = selectedTiles.y + 1 * tileMap.tileSize.height
        } else if (column === numberOfColumns - 1) {
          selectedTilesX = selectedTiles.x + 2 * tileMap.tileSize.width
          selectedTilesY = selectedTiles.y + 1 * tileMap.tileSize.height
        } else {
          selectedTilesX = selectedTiles.x + 1 * tileMap.tileSize.width
          selectedTilesY = selectedTiles.y + 1 * tileMap.tileSize.height
        }

        fn({ row, column }, { x: selectedTilesX, y: selectedTilesY })
      })
    }

    function calculateNumberOfRows(height) {
      return height / tileMap.tileSize.height
    }

    function calculateNumberOfColumns(width) {
      return width / tileMap.tileSize.width
    }

    const menuIconBar = document.querySelector('.menu-icon-bar')
    const toggleGridButton = menuIconBar.querySelector('.toggle-grid-button')

    function updateToggleGridButton() {
      if (isGridShown) {
        toggleGridButton.classList.add('menu-icon-bar__button--enabled')
      } else {
        toggleGridButton.classList.remove('menu-icon-bar__button--enabled')
      }
    }

    updateToggleGridButton()

    menuIconBar.addEventListener('click', function () {
      isGridShown = !isGridShown
      updateToggleGridButton()
      localStorage.setItem('isGridShown', isGridShown)
      renderTileMap()
    })

    const saveTileMap = debounce(function () {
      localStorage.setItem('tileMap', JSON.stringify(tileMap))
    })

    function setTiles(event) {
      const baseX = adjustToStep(event.offsetX, tileMap.tileSize.width)
      const baseY = adjustToStep(event.offsetY, tileMap.tileSize.height)

      let somethingHasChanged = false
      for (let y = 0; y < selectedTiles.height; y += tileMap.tileSize.height) {
        for (let x = 0; x < selectedTiles.width; x += tileMap.tileSize.width) {
          const row = (baseY + y) / tileMap.tileSize.height + 1
          const column = (baseX + x) / tileMap.tileSize.width + 1

          const tile = {
            x: selectedTiles.x + x,
            y: selectedTiles.y + y,
          }

          const hasTileBeenSet = setTile({ row, column }, tile)
          somethingHasChanged = somethingHasChanged || hasTileBeenSet

          const position = { x: baseX + x, y: baseY + y }
          renderTile(position)
        }
      }
      if (somethingHasChanged) {
        renderGrid()
        saveTileMap()
      }
    }

    function setTile({ row, column }, tile) {
      const index = (row - 1) * tileMap.size.width + (column - 1)
      const previousTile = tileMap.tiles[level] && tileMap.tiles[level][index]
      if (!previousTile || areDifferent(previousTile, tile)) {
        if (!tileMap.tiles[level]) {
          tileMap.tiles[level] = new Array(
            tileMap.size.width * tileMap.size.height
          )
        }
        tileMap.tiles[level][index] = tile
        return true
      } else {
        return false
      }
    }

    function renderTiles(area) {
      for (
        let y = area.y;
        y < area.y + area.height;
        y += tileMap.tileSize.height
      ) {
        for (
          let x = area.x;
          x < area.x + area.width;
          x += tileMap.tileSize.width
        ) {
          renderTile({
            x,
            y,
          })
        }
      }
    }

    function renderTile(position, maximumLevel = null) {
      const tile = retrieveTile(position)
      context.clearRect(
        position.x,
        position.y,
        tileMap.tileSize.width,
        tileMap.tileSize.height
      )
      if (tile) {
        if (!maximumLevel) {
          maximumLevel = Math.min(tile.length - 1, level)
        }
        for (let level2 = 0; level2 <= maximumLevel; level2++) {
          const tileOnLayer = tile[level2]
          if (tileOnLayer) {
            context.drawImage(
              $tileSet,
              tileOnLayer.x,
              tileOnLayer.y,
              tileMap.tileSize.width,
              tileMap.tileSize.height,
              position.x,
              position.y,
              tileMap.tileSize.width,
              tileMap.tileSize.height
            )
          }
        }
      } else {
        renderEmptyTile(position)
      }
    }

    function renderSelectedTiles(position, selectedTiles) {
      if (level >= 1) {
        for (
          let y = 0;
          y < selectedTiles.height;
          y += tileMap.tileSize.height
        ) {
          for (
            let x = 0;
            x < selectedTiles.width;
            x += tileMap.tileSize.width
          ) {
            renderTile(
              {
                x: selectedTiles.x + x,
                y: selectedTiles.y + y,
              },
              level
            )
          }
        }
      }

      context.drawImage(
        $tileSet,
        selectedTiles.x,
        selectedTiles.y,
        selectedTiles.width,
        selectedTiles.height,
        position.x,
        position.y,
        selectedTiles.width,
        selectedTiles.height
      )
    }

    function renderEmptyTile(position) {
      context.fillStyle = 'white'
      context.fillRect(
        position.x,
        position.y,
        tileMap.tileSize.width,
        tileMap.tileSize.height
      )
    }

    function areDifferent(a, b) {
      return (
        a.x !== b.x ||
        a.y !== b.y ||
        ((a.width || b.width) && a.width !== b.width) ||
        ((a.height || b.height) && a.height !== b.height)
      )
    }

    function renderPreviewTiles() {
      renderSelectedTiles(previewTiles, selectedTiles)
    }

    function renderTileMap() {
      for (let y = 0; y < tileMap.size.height; y += tileMap.tileSize.height) {
        for (let x = 0; x < tileMap.size.width; x += tileMap.tileSize.width) {
          renderTile({ x, y })
        }
      }

      renderGrid()
    }

    function renderGrid() {
      if (isGridShown) {
        context.fillStyle = 'black'

        for (
          let y = tileMap.tileSize.height;
          y < tileMap.size.height;
          y += tileMap.tileSize.height
        ) {
          context.fillRect(0, y - 1, tileMap.size.width, 2)
        }

        for (
          let x = tileMap.tileSize.width;
          x < tileMap.size.width;
          x += tileMap.tileSize.width
        ) {
          context.fillRect(x, 0, 2, tileMap.size.height)
        }
      }
    }

    function debounce(fn, delay = 1000) {
      let handler = null
      return function (...args) {
        if (handler) {
          clearTimeout(handler)
        }
        handler = setTimeout(() => {
          fn(...args)
        }, delay)
      }
    }

    async function loadMap() {
      const fileHandles = await window.showOpenFilePicker({
        types: [
          {
            description: 'Map',
            accept: {
              'text/json': ['.json'],
            },
          },
        ],
        excludeAcceptAllOption: true,
      })
      const fileHandle = fileHandles[0]
      const file = await fileHandle.getFile()
      const content = await file.text()
      tileMap = JSON.parse(content)
      level = tileMap.tiles.length - 1
      $level.value = level

      $tileHover.style.width = tileMap.tileSize.width + 'px'
      $tileHover.style.height = tileMap.tileSize.height + 'px'

      $tileSelected.style.width = tileMap.tileSize.width + 'px'
      $tileSelected.style.height = tileMap.tileSize.height + 'px'

      renderTileMap()
    }

    async function saveMap() {
      const handle = await window.showSaveFilePicker()
      const stream = await handle.createWritable()
      await stream.write(JSON.stringify(tileMap, null, 2))
      await stream.close()
    }
  </script>
</html>
