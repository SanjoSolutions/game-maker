<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tilemap Editor</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9"
      crossorigin="anonymous"
    />
    <style>
      body {
        display: flex;
        flex-direction: column;
        margin: 0;
        height: 100vh;
      }

      .menu-icon-bar {
        background-color: gainsboro;
      }

      .menu-icon-bar__button--enabled {
        background-color: rgb(250, 250, 250);
      }

      .app-container {
        flex: 1 1 auto;
        display: flex;
        flex-direction: row;
        overflow: hidden;
      }

      .sidebar {
        flex: 0 0 200px;
        overflow: auto;
        position: relative;
      }

      .tile-hover {
        border: 1px solid gainsboro;
        box-sizing: border-box;
        position: absolute;
        pointer-events: none;
      }

      .tile-selected {
        border: 1px solid black;
        box-sizing: border-box;
        position: absolute;
        pointer-events: none;
      }

      .slider {
        flex: 0 0 auto;
        border-right: 1px solid black;
        width: 0;
        cursor: col-resize;
      }

      .main {
        flex: 1 1 auto;
        position: relative;
        background-color: #f1f1f1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .level {
        position: fixed;
        right: 1.5rem;
        bottom: 1.5rem;
        width: 32px;
      }

      .tile-map-container {
        overflow: auto;
      }

      .tile-map {
        display: block;
        background-color: white;
        border-bottom: 1px solid black;
        border-right: 1px solid black;
      }
    </style>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0"
    />
  </head>
  <body>
    <nav class="navbar navbar-expand-lg bg-body-tertiary">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">Tilemap Editor</a>
        <button
          class="navbar-toggler"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarSupportedContent"
          aria-controls="navbarSupportedContent"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item dropdown">
              <a
                class="nav-link dropdown-toggle"
                href="#"
                role="button"
                data-bs-toggle="dropdown"
                aria-expanded="false"
              >
                File
              </a>
              <ul class="dropdown-menu">
                <li>
                  <a
                    class="dropdown-item"
                    href="#"
                    data-bs-toggle="modal"
                    data-bs-target="#tilemapSettings"
                    >Edit tilemap</a
                  >
                </li>
                <li>
                  <a id="importFromFile" class="dropdown-item" href="#"
                    >Import from file</a
                  >
                </li>
                <li>
                  <a id="exportToFile" class="dropdown-item" href="#"
                    >Export to file</a
                  >
                </li>
              </ul>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <div class="app-container">
      <div class="sidebar">
        <img class="tile-set" src="tileset.png" alt="Tileset" />
        <div class="tile-hover" style="display: none"></div>
        <div class="tile-selected" style="display: none"></div>
      </div>
      <div class="slider"></div>
      <div class="main">
        <div class="menu-icon-bar">
          <button type="button" class="pen-tool-button" title="Pen tool">
            <span class="material-symbols-outlined"> ink_pen </span>
          </button>
          <button type="button" class="area-tool-button" title="Draw area tool">
            <span class="material-symbols-outlined"> rectangle </span>
          </button>
          <button type="button" class="fill-tool-button" title="Fill tool">
            <span class="material-symbols-outlined"> format_color_fill </span>
          </button>
          <button type="button" class="toggle-grid-button" title="Toggle grid">
            <span class="material-symbols-outlined"> grid_on </span>
          </button>
          <button
            type="button"
            class="render-only-current-level-button"
            title="Render only current level"
          >
            <span class="material-symbols-outlined"> grid_on </span>
          </button>
        </div>
        <div class="tile-map-container">
          <canvas class="tile-map" width="1024" height="1024"></canvas>
        </div>
        <input class="level" type="number" value="0" title="Level" />
      </div>
    </div>

    <div id="tilemapSettings" class="modal" tabindex="-1">
      <div class="modal-dialog">
        <div class="modal-content">
          <form id="tilemapSettingsForm">
            <div class="modal-header">
              <h5 class="modal-title">Tilemap settings</h5>
              <button
                type="button"
                class="btn-close"
                data-bs-dismiss="modal"
                aria-label="Close"
              ></button>
            </div>
            <div class="modal-body">
              <label for="tilemapSettingsWidth" class="form-label">Width</label>
              <input
                type="number"
                id="tilemapSettingsWidth"
                name="width"
                class="form-control"
              />

              <label for="tilemapSettingsHeight" class="form-label"
                >Height</label
              >
              <input
                type="number"
                id="tilemapSettingsHeight"
                name="height"
                class="form-control"
              />
            </div>
            <div class="modal-footer">
              <button
                type="button"
                class="btn btn-secondary"
                data-bs-dismiss="modal"
              >
                Cancel
              </button>
              <button type="submit" class="btn btn-primary">Save</button>
            </div>
          </form>
        </div>
      </div>
    </div>
  </body>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm"
    crossorigin="anonymous"
  ></script>
  <script>
    let level = 0
    const isGridShownSerialized = localStorage.getItem('isGridShown')
    let activeTool = 'pen'
    let renderOnlyCurrentLevel = false

    let isGridShown = isGridShownSerialized
      ? JSON.parse(isGridShownSerialized)
      : true

    const $level = document.querySelector('.level')

    $level.addEventListener('change', function (event) {
      level = Number(event.target.value)
      renderTileMap()
    })

    const $sidebar = document.querySelector('.sidebar')

    const $slider = document.querySelector('.slider')
    let isSliding = false
    $slider.addEventListener('pointerdown', function (event) {
      event.preventDefault()
      isSliding = true
    })
    window.addEventListener('pointermove', function (event) {
      if (isSliding) {
        event.preventDefault()
        $sidebar.style.flexBasis = event.clientX + 'px'
      }
    })
    window.addEventListener('pointerup', function () {
      isSliding = false
    })

    const $tileHover = document.querySelector('.tile-hover')
    const $tileSet = document.querySelector('.tile-set')
    $tileSet.addEventListener('pointermove', function (event) {
      $tileHover.style.display = 'block'
      $tileHover.style.left =
        adjustToStep(event.offsetX, tileMap.tileSize.width) + 'px'
      $tileHover.style.top =
        adjustToStep(event.offsetY, tileMap.tileSize.height) + 'px'
    })

    const $tileSelected = document.querySelector('.tile-selected')

    let isPointerDownInTileSet = false

    $tileSet.addEventListener('pointerdown', function (event) {
      event.preventDefault()
      isPointerDownInTileSet = true
      selectTile(event)
    })

    $tileSet.addEventListener('pointermove', function (event) {
      if (isPointerDownInTileSet) {
        expandSelectTiles(event)
      }
    })

    $tileSet.addEventListener('mouseleave', function () {
      $tileHover.style.display = 'none'
    })

    let firstPoint = null
    let selectedTiles = null

    function selectTile(event) {
      const x = adjustToStep(event.offsetX, tileMap.tileSize.width)
      const y = adjustToStep(event.offsetY, tileMap.tileSize.height)
      firstPoint = {
        x,
        y,
      }
      selectedTiles = {
        x,
        y,
        width: tileMap.tileSize.width,
        height: tileMap.tileSize.height,
      }
      $tileSelected.style.display = 'block'
      $tileSelected.style.left = selectedTiles.x + 'px'
      $tileSelected.style.top = selectedTiles.y + 'px'
      $tileSelected.style.width = selectedTiles.width + 'px'
      $tileSelected.style.height = selectedTiles.height + 'px'
    }

    function expandSelectTiles(event) {
      const x = adjustToStep(event.offsetX, tileMap.tileSize.width)
      const y = adjustToStep(event.offsetY, tileMap.tileSize.height)
      selectedTiles = {
        x: Math.min(firstPoint.x, x),
        y: Math.min(firstPoint.y, y),
        width: Math.abs(x - firstPoint.x) + tileMap.tileSize.width,
        height: Math.abs(y - firstPoint.y) + tileMap.tileSize.height,
      }
      $tileSelected.style.left = selectedTiles.x + 'px'
      $tileSelected.style.top = selectedTiles.y + 'px'
      $tileSelected.style.width = selectedTiles.width + 'px'
      $tileSelected.style.height = selectedTiles.height + 'px'
    }

    window.addEventListener('pointerup', function () {
      isPointerDownInTileSet = false
    })

    function adjustToStep(value, step) {
      return Math.floor(value / step) * step
    }

    const $canvas = document.querySelector('.tile-map')
    const context = $canvas.getContext('2d')

    let previewTiles = null

    const DEFAULT_TILE_WIDTH = 32
    const DEFAULT_TILE_HEIGHT = 32
    const DEFAULT_MAP_WIDTH = 512
    const DEFAULT_MAP_HEIGHT = 512
    const tileMapSerialized = localStorage.getItem('tileMap')
    let tileMap = tileMapSerialized
      ? JSON.parse(tileMapSerialized)
      : {
          size: {
            width: DEFAULT_MAP_WIDTH,
            height: DEFAULT_MAP_HEIGHT,
          },
          tileSize: {
            width: DEFAULT_TILE_WIDTH,
            height: DEFAULT_TILE_HEIGHT,
          },
          tiles: [
            new Array(
              Math.ceil(DEFAULT_MAP_WIDTH / DEFAULT_TILE_WIDTH) *
                Math.ceil(DEFAULT_MAP_HEIGHT / DEFAULT_TILE_HEIGHT)
            ),
          ],
        }

    $canvas.width = tileMap.size.width
    $canvas.height = tileMap.size.height

    level = tileMap.tiles.length - 1
    $level.value = level

    $tileHover.style.width = tileMap.tileSize.width + 'px'
    $tileHover.style.height = tileMap.tileSize.height + 'px'

    $tileSelected.style.width = tileMap.tileSize.width + 'px'
    $tileSelected.style.height = tileMap.tileSize.height + 'px'

    renderGrid()

    if (tileMapSerialized) {
      if ($tileSet.complete) {
        renderTileMap()
      } else {
        $tileSet.addEventListener('load', function () {
          renderTileMap()
        })
      }
    }

    function retrieveTile(position) {
      const row = position.y / tileMap.tileSize.height
      const column = position.x / tileMap.tileSize.width
      return retrieveTile2({ row, column })
    }

    function retrieveTile2({ row, column }) {
      const index = calculateIndex({ row, column })
      return tileMap.tiles.map(levelTileMap =>
        levelTileMap ? levelTileMap[index] : null
      )
    }

    let firstPointTileMap = null
    let selectedTilesInTileMap = null
    let isPointerDownInTileMap = false

    $canvas.addEventListener('pointerdown', function (event) {
      event.preventDefault()
      isPointerDownInTileMap = true

      if (activeTool === 'fill') {
        fill(event)
      } else {
        selectTileInTileMap(event)

        if (selectedTiles) {
          if (activeTool === 'pen') {
            setTiles(event)
          }
        }
      }
    })

    function previewFill(event) {
      doAFillMethod(event, function (tile, selectedTile) {
        const replacements = []
        replacements[level] = selectedTile
        renderTile(
          {
            x: tile.column * tileMap.tileSize.width,
            y: tile.row * tileMap.tileSize.height,
          },
          replacements
        )
      })
    }

    function fill(event) {
      backUpMap()
      doAFillMethod(event, function (tile, selectedTile) {
        setTile(tile, selectedTile)
      })
      renderTileMap()
      saveTileMap()
    }

    const backups = []

    function backUpMap() {
      console.log('backUp')
      backups.push(copyMap(tileMap))
    }

    function copyMap(tileMap) {
      return {
        size: { ...tileMap.size },
        tileSize: { ...tileMap.tileSize },
        tiles: tileMap.tiles.map(tiles => Array.from(tiles)),
      }
    }

    function doAFillMethod(event, fn) {
      const origin = {
        row:
          adjustToStep(event.offsetY, tileMap.tileSize.height) /
          tileMap.tileSize.height,
        column:
          adjustToStep(event.offsetX, tileMap.tileSize.width) /
          tileMap.tileSize.width,
      }

      const originTileBeforeFill = retrieveTile2(origin)[level]

      const selectedTile = {
        x: selectedTiles.x,
        y: selectedTiles.y,
        width: tileMap.tileSize.width,
        height: tileMap.tileSize.height,
      }

      const visitedTiles = new Set()

      function setAsVisited(tile) {
        const index = calculateIndex(tile)
        visitedTiles.add(index)
      }

      function hasNotBeenVisited(tile) {
        const index = calculateIndex(tile)
        return !visitedTiles.has(index)
      }

      let nextTiles = [origin]

      do {
        const tiles = nextTiles
        nextTiles = []
        for (const tile of tiles) {
          if (hasNotBeenVisited(tile)) {
            fn(tile, selectedTile)
            setAsVisited(tile)
            const neighbors = retrieveNeighborsWithSetTile(
              tile,
              originTileBeforeFill
            ).filter(hasNotBeenVisited)
            nextTiles.push(...neighbors)
          }
        }
      } while (nextTiles.length >= 1)
    }

    function retrieveNeighborsWithSetTile(tile, setTile) {
      return retrieveNeighbors(tile).filter(tile => isTileSetTo(tile, setTile))
    }

    function retrieveNeighbors(tile) {
      const neighbors = []
      if (tile.row >= 1) {
        neighbors.push({
          row: tile.row - 1,
          column: tile.column,
        })
      }
      const numberOfColumns = tileMap.size.width / tileMap.tileSize.width
      if (tile.column < numberOfColumns - 1) {
        neighbors.push({
          row: tile.row,
          column: tile.column + 1,
        })
      }
      const numberOfRows = tileMap.size.height / tileMap.tileSize.height
      if (tile.row < numberOfRows - 1) {
        neighbors.push({
          row: tile.row + 1,
          column: tile.column,
        })
      }
      if (tile.column >= 1) {
        neighbors.push({
          row: tile.row,
          column: tile.column - 1,
        })
      }
      return neighbors
    }

    function isTileSetTo(tile, setTile) {
      const a = retrieveTile2(tile)
      const b = a ? a[level] ?? null : null
      return (
        (!b && !setTile) ||
        (b && setTile && b.x === setTile.x && b.y === setTile.y)
      )
    }

    function selectTileInTileMap(event) {
      const x = adjustToStep(event.offsetX, tileMap.tileSize.width)
      const y = adjustToStep(event.offsetY, tileMap.tileSize.height)
      firstPointTileMap = {
        x,
        y,
      }

      selectedTilesInTileMap = {
        x,
        y,
        width: tileMap.tileSize.width,
        height: tileMap.tileSize.height,
      }
    }

    function preview9SliceMade() {
      renderTileMap()

      do9SliceMethodWithSelectedTiles(function ({ row, column }, tile) {
        context.drawImage(
          $tileSet,
          tile.x,
          tile.y,
          tileMap.tileSize.width,
          tileMap.tileSize.height,
          selectedTilesInTileMap.x + column * tileMap.tileSize.width,
          selectedTilesInTileMap.y + row * tileMap.tileSize.height,
          tileMap.tileSize.width,
          tileMap.tileSize.height
        )
      })
    }

    function previewArea() {
      renderTileMap()

      const numberOfRows = selectedTiles.height / tileMap.tileSize.height
      const numberOfColumns = selectedTiles.width / tileMap.tileSize.width
      doSomethingWithSelectedTilesInTileMap(function ({ row, column }) {
        context.drawImage(
          $tileSet,
          selectedTiles.x + (column % numberOfColumns) * tileMap.tileSize.width,
          selectedTiles.y + (row % numberOfRows) * tileMap.tileSize.height,
          tileMap.tileSize.width,
          tileMap.tileSize.height,
          selectedTilesInTileMap.x + column * tileMap.tileSize.width,
          selectedTilesInTileMap.y + row * tileMap.tileSize.height,
          tileMap.tileSize.width,
          tileMap.tileSize.height
        )
      })
    }

    $canvas.addEventListener('pointermove', function (event) {
      if (selectedTiles) {
        if (isPointerDownInTileMap) {
          if (activeTool === 'area') {
            expandSelectTilesInTileMap(event)
            if (seemsThat9SliceIsSelected()) {
              preview9SliceMade()
              renderGrid()
            } else {
              previewArea()
              renderGrid()
            }
          } else if (activeTool === 'pen') {
            setTiles(event)
            renderGrid()
          }
        } else {
          if (activeTool === 'pen') {
            const previousPreviewTiles = previewTiles
            previewTiles = {
              x: adjustToStep(event.offsetX, tileMap.tileSize.width),
              y: adjustToStep(event.offsetY, tileMap.tileSize.height),
              width: selectedTiles.width,
              height: selectedTiles.height,
            }
            if (
              !previousPreviewTiles ||
              areDifferent(previousPreviewTiles, previewTiles)
            ) {
              if (previousPreviewTiles) {
                renderTiles(previousPreviewTiles)
              }
              renderPreviewTiles()
              renderGrid()
            }
          } else if (activeTool === 'area') {
            const previousPreviewTiles = previewTiles
            previewTiles = {
              x: adjustToStep(event.offsetX, tileMap.tileSize.width),
              y: adjustToStep(event.offsetY, tileMap.tileSize.height),
              width: tileMap.tileSize.width,
              height: tileMap.tileSize.height,
            }
            if (
              !previousPreviewTiles ||
              areDifferent(previousPreviewTiles, previewTiles)
            ) {
              if (previousPreviewTiles) {
                renderTiles(previousPreviewTiles)
              }
              renderPreviewTiles()
              renderGrid()
            }
          } else if (activeTool === 'fill') {
            renderTileMap()
            previewFill(event)
            renderGrid()
          }
        }
      }
    })

    function expandSelectTilesInTileMap(event) {
      const x = adjustToStep(event.offsetX, tileMap.tileSize.width)
      const y = adjustToStep(event.offsetY, tileMap.tileSize.height)
      selectedTilesInTileMap = {
        x: Math.min(firstPointTileMap.x, x),
        y: Math.min(firstPointTileMap.y, y),
        width: Math.abs(x - firstPointTileMap.x) + tileMap.tileSize.width,
        height: Math.abs(y - firstPointTileMap.y) + tileMap.tileSize.height,
      }
    }

    function seemsThat9SliceIsSelected() {
      return (
        selectedTiles.width === 3 * tileMap.tileSize.height &&
        selectedTiles.height === 3 * tileMap.tileSize.height
      )
    }

    $canvas.addEventListener('mouseleave', function () {
      previewTiles = null
      renderTileMap()
    })

    window.addEventListener('pointerup', function () {
      const wasPointerDownInTileMap = isPointerDownInTileMap

      isPointerDownInTileMap = false

      if (wasPointerDownInTileMap) {
        if (activeTool === 'area') {
          if (seemsThat9SliceIsSelected()) {
            setTilesWith9SliceMethod()
          } else {
            area()
          }
        }
      }

      firstPointTileMap = null
      selectedTilesInTileMap = null
    })

    function putSelectedTilesOnMap() {
      setTiles({
        offsetX: firstPointTileMap.x,
        offsetY: firstPointTileMap.y,
      })
    }

    function area() {
      backUpMap()

      const numberOfRows = selectedTiles.height / tileMap.tileSize.height
      const numberOfColumns = selectedTiles.width / tileMap.tileSize.width
      const baseRow = selectedTilesInTileMap.y / tileMap.tileSize.height
      const baseColumn = selectedTilesInTileMap.x / tileMap.tileSize.width
      doSomethingWithSelectedTilesInTileMap(function ({ row, column }) {
        const selectedTile = {
          x:
            selectedTiles.x +
            (column % numberOfColumns) * tileMap.tileSize.width,
          y: selectedTiles.y + (row % numberOfRows) * tileMap.tileSize.height,
        }
        setTile(
          { row: baseRow + row, column: baseColumn + column },
          selectedTile
        )
      })
      renderTileMap()
      saveTileMap()
    }

    function setTilesWith9SliceMethod() {
      backUpMap()

      const baseRow =
        adjustToStep(selectedTilesInTileMap.y, tileMap.tileSize.height) /
        tileMap.tileSize.height
      const baseColumn =
        adjustToStep(selectedTilesInTileMap.x, tileMap.tileSize.width) /
        tileMap.tileSize.width

      do9SliceMethodWithSelectedTiles(function ({ row, column }, tile) {
        setTile(
          {
            row: baseRow + row,
            column: baseColumn + column,
          },
          tile
        )
      })
    }

    function doSomethingWithSelectedTilesInTileMap(fn) {
      const numberOfRows = calculateNumberOfRows(selectedTilesInTileMap.height)
      const numberOfColumns = calculateNumberOfColumns(
        selectedTilesInTileMap.width
      )

      for (let row = 0; row < numberOfRows; row++) {
        for (let column = 0; column < numberOfColumns; column++) {
          fn({ row, column })
        }
      }
    }

    function do9SliceMethodWithSelectedTiles(fn) {
      const numberOfRows = calculateNumberOfRows(selectedTilesInTileMap.height)
      const numberOfColumns = calculateNumberOfColumns(
        selectedTilesInTileMap.width
      )

      doSomethingWithSelectedTilesInTileMap(function ({ row, column }) {
        let selectedTilesX
        let selectedTilesY

        if (row === 0 && column === 0) {
          selectedTilesX = selectedTiles.x
          selectedTilesY = selectedTiles.y
        } else if (row === 0 && column === numberOfColumns - 1) {
          ;(selectedTilesX = selectedTiles.x + 2 * tileMap.tileSize.width),
            (selectedTilesY = selectedTiles.y)
        } else if (row === numberOfRows - 1 && column === numberOfColumns - 1) {
          selectedTilesX = selectedTiles.x + 2 * tileMap.tileSize.width
          selectedTilesY = selectedTiles.y + 2 * tileMap.tileSize.height
        } else if (row === numberOfRows - 1 && column === 0) {
          selectedTilesX = selectedTiles.x
          selectedTilesY = selectedTiles.y + 2 * tileMap.tileSize.height
        } else if (row === 0) {
          selectedTilesX = selectedTiles.x + 1 * tileMap.tileSize.width
          selectedTilesY = selectedTiles.y
        } else if (row === numberOfRows - 1) {
          selectedTilesX = selectedTiles.x + 1 * tileMap.tileSize.width
          selectedTilesY = selectedTiles.y + 2 * tileMap.tileSize.height
        } else if (column === 0) {
          selectedTilesX = selectedTiles.x
          selectedTilesY = selectedTiles.y + 1 * tileMap.tileSize.height
        } else if (column === numberOfColumns - 1) {
          selectedTilesX = selectedTiles.x + 2 * tileMap.tileSize.width
          selectedTilesY = selectedTiles.y + 1 * tileMap.tileSize.height
        } else {
          selectedTilesX = selectedTiles.x + 1 * tileMap.tileSize.width
          selectedTilesY = selectedTiles.y + 1 * tileMap.tileSize.height
        }

        fn({ row, column }, { x: selectedTilesX, y: selectedTilesY })
      })
    }

    function calculateNumberOfRows(height) {
      return height / tileMap.tileSize.height
    }

    function calculateNumberOfColumns(width) {
      return width / tileMap.tileSize.width
    }

    const menuIconBar = document.querySelector('.menu-icon-bar')
    const toggleGridButton = menuIconBar.querySelector('.toggle-grid-button')

    function updateToggleGridButton() {
      if (isGridShown) {
        toggleGridButton.classList.add('menu-icon-bar__button--enabled')
      } else {
        toggleGridButton.classList.remove('menu-icon-bar__button--enabled')
      }
    }

    updateToggleGridButton()

    toggleGridButton.addEventListener('click', function () {
      isGridShown = !isGridShown
      updateToggleGridButton()
      localStorage.setItem('isGridShown', isGridShown)
      renderTileMap()
    })

    function updateToolButtonStates() {
      updatePenToolButton()
      updateFillToolButton()
    }

    function updateToolButton(button, tool) {
      if (activeTool === tool) {
        button.classList.add('menu-icon-bar__button--enabled')
      } else {
        button.classList.remove('menu-icon-bar__button--enabled')
      }
    }

    const penToolButton = menuIconBar.querySelector('.pen-tool-button')
    penToolButton.addEventListener('click', function () {
      activeTool = 'pen'
      updateToolButtonStates()
    })

    function updatePenToolButton() {
      updateToolButton(penToolButton, 'pen')
    }

    const areaToolButton = menuIconBar.querySelector('.area-tool-button')
    areaToolButton.addEventListener('click', function () {
      activeTool = 'area'
      updateToolButtonStates()
    })

    function updateAreaToolButton() {
      updateToolButton(areaToolButton, 'area')
    }

    const fillToolButton = menuIconBar.querySelector('.fill-tool-button')
    fillToolButton.addEventListener('click', function () {
      activeTool = 'fill'
      updateToolButtonStates()
    })

    function updateFillToolButton() {
      updateToolButton(fillToolButton, 'fill')
    }

    updateToolButtonStates()

    const renderOnlyCurrentLevelButton = document.querySelector(
      '.render-only-current-level-button'
    )
    renderOnlyCurrentLevelButton.addEventListener('click', function () {
      renderOnlyCurrentLevel = !renderOnlyCurrentLevel
      renderTileMap()
    })

    const saveTileMap = debounce(function () {
      localStorage.setItem('tileMap', JSON.stringify(tileMap))
    })

    const tilemapSettingsModal = document.querySelector('#tilemapSettings')
    const modal = new bootstrap.Modal(tilemapSettingsModal)

    tilemapSettingsModal.addEventListener('show.bs.modal', function () {
      tilemapSettingsModal.querySelector('#tilemapSettingsWidth').value =
        tileMap.size.width / tileMap.tileSize.width
      tilemapSettingsModal.querySelector('#tilemapSettingsHeight').value =
        tileMap.size.height / tileMap.tileSize.height
    })

    tilemapSettingsModal.addEventListener('shown.bs.modal', function () {
      const $width = tilemapSettingsModal.querySelector('#tilemapSettingsWidth')
      $width.focus()
      $width.select()
    })

    tilemapSettingsModal
      .querySelector('#tilemapSettingsForm')
      .addEventListener('submit', function (event) {
        event.preventDefault()

        const formData = new FormData(event.target)

        const width = parseInt(formData.get('width'), 10)
        const height = parseInt(formData.get('height'), 10)

        resizeMap({
          width: width * tileMap.tileSize.width,
          height: height * tileMap.tileSize.height,
        })

        $canvas.width = tileMap.size.width
        $canvas.height = tileMap.size.height

        renderTileMap()

        saveTileMap()

        modal.hide()
      })

    function resizeMap({ width, height }) {
      backUpMap()

      const oldNumberOfRows = Math.ceil(
        tileMap.size.height / tileMap.tileSize.height
      )
      const oldNumberOfColumns = Math.ceil(
        tileMap.size.width / tileMap.tileSize.width
      )
      const numberOfRows = Math.ceil(height / tileMap.tileSize.height)
      const numberOfColumns = Math.ceil(width / tileMap.tileSize.width)
      tileMap.tiles = tileMap.tiles.map(function (oldTiles) {
        const updatedTiles = new Array(numberOfRows * numberOfColumns)
        for (
          let row = 0;
          row < Math.min(oldNumberOfRows, numberOfRows);
          row++
        ) {
          const startIndex = row * oldNumberOfColumns
          for (
            let index = 0;
            index < Math.min(oldNumberOfColumns, numberOfColumns);
            index++
          ) {
            updatedTiles[row * numberOfColumns + index] =
              oldTiles[startIndex + index]
          }
        }
        return updatedTiles
      })
      tileMap.size.width = width
      tileMap.size.height = height
    }

    function setTiles(event) {
      backUpMap()

      const baseX = adjustToStep(event.offsetX, tileMap.tileSize.width)
      const baseY = adjustToStep(event.offsetY, tileMap.tileSize.height)

      let somethingHasChanged = false
      for (let y = 0; y < selectedTiles.height; y += tileMap.tileSize.height) {
        for (let x = 0; x < selectedTiles.width; x += tileMap.tileSize.width) {
          const row = (baseY + y) / tileMap.tileSize.height
          const column = (baseX + x) / tileMap.tileSize.width

          const tile = {
            x: selectedTiles.x + x,
            y: selectedTiles.y + y,
          }

          const hasTileBeenSet = setTile({ row, column }, tile)
          somethingHasChanged = somethingHasChanged || hasTileBeenSet

          const position = { x: baseX + x, y: baseY + y }
          renderTile(position)
        }
      }
      if (somethingHasChanged) {
        renderGrid()
        saveTileMap()
      } else {
        backups.pop()
      }
    }

    function calculateIndex({ row, column }) {
      return (
        row * Math.ceil(tileMap.size.width / tileMap.tileSize.width) + column
      )
    }

    function setTile({ row, column }, tile) {
      const index = calculateIndex({ row, column })
      const previousTile = tileMap.tiles[level] && tileMap.tiles[level][index]
      if (!previousTile || areDifferent(previousTile, tile)) {
        if (!tileMap.tiles[level]) {
          tileMap.tiles[level] = new Array(
            Math.ceil(tileMap.size.width / tileMap.tileSize.width) *
              Math.ceil(tileMap.size.height / tileMap.tileSize.height)
          )
        }
        tileMap.tiles[level][index] = tile
        return true
      } else {
        return false
      }
    }

    function renderTiles(area) {
      for (
        let y = area.y;
        y < area.y + area.height;
        y += tileMap.tileSize.height
      ) {
        for (
          let x = area.x;
          x < area.x + area.width;
          x += tileMap.tileSize.width
        ) {
          renderTile({
            x,
            y,
          })
        }
      }
    }

    function renderTile(position, replacements = null) {
      const tile = retrieveTile(position)
      context.clearRect(
        position.x,
        position.y,
        tileMap.tileSize.width,
        tileMap.tileSize.height
      )
      if (tile) {
        context.save()
        function a(level2) {
          const tileOnLayer =
            replacements && replacements[level2]
              ? replacements[level2]
              : tile[level2]
          if (tileOnLayer) {
            context.globalAlpha = level2 > level ? 0.4 : 1
            context.drawImage(
              $tileSet,
              tileOnLayer.x,
              tileOnLayer.y,
              tileMap.tileSize.width,
              tileMap.tileSize.height,
              position.x,
              position.y,
              tileMap.tileSize.width,
              tileMap.tileSize.height
            )
          }
        }
        if (renderOnlyCurrentLevel) {
          a(level)
        } else {
          for (let level2 = 0; level2 < tile.length; level2++) {
            a(level2)
          }
        }
        context.restore()
      } else {
        renderEmptyTile(position)
      }
    }

    function renderSelectedTiles(area, selectedTiles) {
      for (let y = 0; y < area.height; y += tileMap.tileSize.height) {
        for (let x = 0; x < area.width; x += tileMap.tileSize.width) {
          const replacements = []
          replacements[level] = {
            x: selectedTiles.x + x,
            y: selectedTiles.y + y,
          }
          renderTile(
            {
              x: area.x + x,
              y: area.y + y,
            },
            replacements
          )
        }
      }

      renderGrid()
    }

    function renderEmptyTile(position) {
      context.fillStyle = 'white'
      context.fillRect(
        position.x,
        position.y,
        tileMap.tileSize.width,
        tileMap.tileSize.height
      )
    }

    function areDifferent(a, b) {
      return (
        a.x !== b.x ||
        a.y !== b.y ||
        ((a.width || b.width) && a.width !== b.width) ||
        ((a.height || b.height) && a.height !== b.height)
      )
    }

    function renderPreviewTiles() {
      renderSelectedTiles(previewTiles, selectedTiles)
    }

    function renderTileMap() {
      for (let y = 0; y < tileMap.size.height; y += tileMap.tileSize.height) {
        for (let x = 0; x < tileMap.size.width; x += tileMap.tileSize.width) {
          renderTile({ x, y })
        }
      }

      renderGrid()
    }

    function renderGrid() {
      if (isGridShown) {
        context.fillStyle = 'black'

        for (
          let y = tileMap.tileSize.height;
          y < tileMap.size.height;
          y += tileMap.tileSize.height
        ) {
          context.fillRect(0, y - 1, tileMap.size.width, 2)
        }

        for (
          let x = tileMap.tileSize.width;
          x < tileMap.size.width;
          x += tileMap.tileSize.width
        ) {
          context.fillRect(x, 0, 2, tileMap.size.height)
        }
      }
    }

    function debounce(fn, delay = 1000) {
      let handler = null
      return function (...args) {
        if (handler) {
          clearTimeout(handler)
        }
        handler = setTimeout(() => {
          fn(...args)
        }, delay)
      }
    }

    const types = [
      {
        description: 'Map',
        accept: {
          'text/json': ['.json'],
        },
      },
    ]

    const filePickerBaseOptions = {
      excludeAcceptAllOption: true,
      types,
    }

    async function loadMap() {
      const fileHandles = await window.showOpenFilePicker(filePickerBaseOptions)
      const fileHandle = fileHandles[0]
      const file = await fileHandle.getFile()
      const content = await file.text()
      tileMap = JSON.parse(content)
      level = tileMap.tiles.length - 1
      $level.value = level

      $canvas.width = tileMap.size.width
      $canvas.height = tileMap.size.height

      $tileHover.style.width = tileMap.tileSize.width + 'px'
      $tileHover.style.height = tileMap.tileSize.height + 'px'

      $tileSelected.style.width = tileMap.tileSize.width + 'px'
      $tileSelected.style.height = tileMap.tileSize.height + 'px'

      renderTileMap()

      saveTileMap()
    }

    async function saveMap() {
      const handle = await window.showSaveFilePicker({
        ...filePickerBaseOptions,
        suggestedName: 'map.json',
      })
      const stream = await handle.createWritable()
      await stream.write(JSON.stringify(tileMap, null, 2))
      await stream.close()
    }

    window.addEventListener('keydown', function (event) {
      if (event.ctrlKey && event.key === 'z') {
        event.preventDefault()
        undo()
      }
    })

    function undo() {
      console.log('undo')
      const lastBackup = backups.pop()
      if (lastBackup) {
        const oldTileMap = tileMap
        tileMap = lastBackup
        if (tileMap.size.width !== oldTileMap.size.width) {
          canvas.width = tileMap.size.width
        }
        if (tileMap.size.height !== oldTileMap.size.height) {
          canvas.height = tileMap.size.height
        }
        renderTileMap()
        saveTileMap()
      }
    }

    document
      .querySelector('#exportToFile')
      .addEventListener('click', function (event) {
        event.preventDefault()
        saveMap()
      })

    document
      .querySelector('#importFromFile')
      .addEventListener('click', function (event) {
        event.preventDefault()
        loadMap()
      })
  </script>
</html>
